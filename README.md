# DZBLEManager


### 部分逻辑介绍

````swift
### **多设备状态管理**
```
设备A: [扫描] → [连接中] → [已连接] → [就绪] 💓心跳中
                                        ↓
设备B: [扫描] → [连接中] → [已连接] → [就绪] 💓心跳中
                                        ↓
设备C: [扫描] → [连接中] → [已连接] → [就绪] 💓心跳中



# 📊 架构对比

### 方案A：集中式（原方案）
```
┌──────────────────────────────────┐
│   MultiDeviceBluetoothManager    │
│   (CBPeripheralDelegate)          │
└──────────────────────────────────┘
              ↓
    所有设备的回调都到这里
              ↓
┌──────────────────────────────────┐
│ func peripheral(...) {            │
│   // 步骤1: 查找设备               │
│   guard let context =             │
│     connectedDevices[id] else {}  │
│                                   │
│   // 步骤2: 转发处理               │
│   context.handleXXX()             │
│ }                                 │
└──────────────────────────────────┘
```

**缺点：**
- 需要通过 `peripheral.identifier` 查找
- Manager 代码会很庞大
- 所有设备回调混在一起

### 方案B：分散式（优化方案）⭐️
```
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│  BluetoothDevice │  │  BluetoothDevice │  │  BluetoothDevice │
│  (自己是delegate) │  │  (自己是delegate) │  │  (自己是delegate) │
└─────────────────┘  └─────────────────┘  └─────────────────┘
        ↓                    ↓                    ↓
   处理自己的回调       处理自己的回调       处理自己的回调
        ↓                    ↓                    ↓
   直接访问资源         直接访问资源         直接访问资源
   (无需查找)          (无需查找)          (无需查找)
        ↓                    ↓                    ↓
  通知Manager事件      通知Manager事件      通知Manager事件




# 🎨 架构优势

### 1. **职责更清晰**
```
MultiDeviceBluetoothManager：
- 扫描设备 ✅
- 连接/断开 ✅
- 事件广播 ✅
- 全局协调 ✅

Device：
- 管理自己的连接 ✅
- 处理自己的数据 ✅
- 执行自己的指令 ✅
- 监控自己的质量 ✅
````

